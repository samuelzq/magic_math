# 第三章 9的魔力

## **最具魔力的数**

        当我还是个孩子时，我最喜欢的数是9，因为它看起来具有那么多神奇的属性。遵照下面的指令，你将看到一个例子。

1. 在1和10之间选一个数（或者选择一个更大的整数并使用计算器，如果你愿意的话）。
2. 将你选的数乘以3。
3. 加上6。
4. 再次将你的数乘以3。
5. 如果你愿意，把你的数乘以2。
6. 将各位的值相加。如果结果是一位数，则停止。
7. 如果总和是一个两位数，那么将两个位值相加。
8. 专注于你的答案。

        我清楚地感觉到你现在正在考虑为什么会得到9。是这样吗？如果不是这样，请仔细检查你的计算过程。

        数9有什么神奇的地方呢？在本章余下的部分，我们将看到它的一些神奇的属性。我们甚至将考虑一个12与3具有相同功能的世界。9的第一个神奇属性可以通过通过它的倍数来观察。

        9、18、27、36、45、54、63、72、81、90、99、108、117、126、135、144 . . .

        这些数有什么共同之处呢？如果你将每个数的位值加起来，你总是会得到9。让我们验证其中的几个：18的位值和是1 + 8 = 9；27的位值和是2 + 7 =  9；144的位值和是1+ 4 + 4 = 9。但是等等，这里有一个例外：99的位值和是9 + 9 = 18，但是18仍然是9的倍数。这样我们得到一个重要的结论，你可能在小学中学到过，而我会在后续章节中解释：

        **如果一个数是9的倍数，则它的位值之和是9的倍数（反之亦然）。**

        例如123456789的位值之和45是9的倍数，因此它是9的倍数。相反314159的位值之和23不是9的倍数，所以它不是9的倍数。

        为使用这个原理来理解我们前面的魔术技巧，让我们来检查一下代数。你从一个数开始，我们称之为N。三倍之后是3N。加上6之后是3N + 6。在乘以3是3\(3N + 6\) = 9N + 18，也可写做9\(N + 2\)。如果你决定将结果加倍，则得到18N + 36 = 9\(2N + 4）。不管怎样，你的最终答案是9乘以一个整数，因此你肯定得到一个9的倍数。当你将该数的位值加起来时，你肯定再次得到一个9的倍数（很可能是9、18、27或36），这些数的位值之和肯定是9。

        下面是前一个魔术的一个变种。让一个人在计算器上秘密的在下面的4位数中做出选择：

        3141、2718、2358、9999

        这些数是π 的前四位，e的前四位，连续的斐波那契数，最大的4位数。

        接着令他用任意一个三位数乘上他的选择。结果是一个你不可能知道的6位数或7位数。接下来让他们在脑海中圈出他们乘积中的一个数字，但是不要圈出0（因为它已经是一个圆圈了！），让他们按照他们想要的任何顺序背诵所有未被圈下的数，最后你来猜那个被圈的数字是几。只要你专心一点，你就能成功地揭晓答案。

        那么秘密是什么呢？请注意所有这四个数都是9的倍数。既然你从一个9的倍数开始计算，并且将它和一个整数相乘，结果必然是9的倍数，即位值之和必然是9的倍数。当每一位上的数被召唤出来时，简单地将它们加起来。缺失的那个数就是使位值之和等于9的倍数的数。例如，假设观众喊出的数是5、0、2、2、6和1。这些数之和是16，最接近的9的倍数是18，所以剩下的数必须是2。如果观众喊出的数是1、1、2、3、5、8，它们的和为20，则缺失的数是7。如果所有被喊出的数之和是18，那么缺失的数是多少呢？既然规则规定不能圈0，所依缺失的数只能是9。

        为何9的倍数的位值之和还是9的倍数呢？让我们看一个例子。当3456被用10的幂表示时，是这样的

3456 = \(3 × 1000\) + \(4 × 100\) + \(5 × 10\) + 6

         = 3\(999 + 1\) + 4\(99 + 1\) + 5\(9 + 1\) + 6

         = 3\(999\) + 4\(99\) + 5\(9\) + 3 + 4 + 5 + 6

         = \(9的倍数\) + 18

         = 9的倍数

        通过相同的逻辑，一个数一旦其位值之和为9的倍数，则它也必然是9的倍数（反之亦然，如果一个数是9的倍数，则它的位值之和是9的倍数）。  


## 舍九法

        当位值之和不是9的倍数时，会发生什么呢？例如3457，根据上面的步骤，我们可以将这个数写成3\(999\) + 4\(99\) + 5\(9\) + 7 + 12，其中7 + 12 = 19大于9的倍数。既然19 = 18 + 1，这意味着3457比9的倍数大1。我们可以通过求19的位值和得出同样的结论。我将此过程简化为3457 → 19 → 10 → 1。

        不断地将位值相加直到得到一个一位数的过程被称为**舍九法**。因为计算的每一步中，你都会减去一个9的倍数。最后一步所得到的一位数被称为原始数的数字根。例如3457的数字根是1。3456的数字根是9。我们可以简单地总结之前的结论。对于任意一个正数n：

        **如果n的数字根是9，则n是9的倍数。如果数字根不是9，则是n被9除时的余数。**

        下面的代数式描述得更清晰一些。如果n的数字根是r，则

$$
n = 9x + r
$$

        对于整数x，舍九法可以是一个用来检查加减乘结果的有趣方法。例如，如果加法的结果正确，则和的数字根等于相加两个数的数字根之和。这里是一个例子

![](.gitbook/assets/image%20%2837%29.png)

        注意两个加数的数字根之和是11，11的数字根是2。答案的数字根也是2并非是巧合。这一验证过程的有效性是有代数基础的

$$
(9x + r1) + (9y + r2) = 9(x + y) + (r1 + r2)
$$

        如果两个数字根不匹配，则你肯定在的计算过程中出了错误。重要的是：数字根匹配并不一定能够保证你的计算一定正确。不过这一过程能够发现计算过程中90%随机出现的错误。注意，这一方法不能够发现数位颠倒这种类型的错误，因为将两个数位上的数字颠倒并不能使位值之和发生变化。但是如果一位数字发生错误，该错误将会被检测出来，除非这个错误将0变成9或者9变成了0。即使在加数很多的情况下，我们也可应用这一过程检测结果是否正确。假如你购买了以下商品：

![](.gitbook/assets/image%20%2820%29.png)

        结果的数字根是5。加数的数字根之和是32。32的数字根是5，所以总和与加数的数字根之和匹配。舍九法也可以被应用在减法上。现在我们将最初的例子改为减法。

![](.gitbook/assets/image%20%2829%29.png)

        差48923的数字根是8。相减两数数字根之差5 - 6 = -1。因为加上9的倍数不会改变数字根，-1 + 9 = 8，所以数字根的差与差的数字根匹配。

        让我们利用我们所学到的知识创造另一个魔术（就像本书曾经介绍过的一样）。遵照下面的步骤，如果愿意你可以使用计算器：

1. 想一个两位数或者三位数
2. 将位值相加
3. 从初始值中减去位值和
4. 再求位值之和
5. 如果位值和是偶数则乘以5，如果位值和是奇数则乘以10
6. 将结果减去15

        你想到答案是75吗？

        假如你从47开始，4 + 7 = 11，47 - 1 = 36，3 + 6 = 9，9 × 10 = 90，90 - 15 = 75。如果你选了一个三位数，假设是831。8 + 3 + 1 = 12，831 – 12 = 819，8 + 1 + 9 = 18，18 × 5 = 90，90 – 15 = 75。

        这一技巧有效的原因是：如果你想的数的位值和是T，则这个数肯定比9的倍数大T。当我们从初始值中减去T时，我们将得到一个小于999的9的倍数，它的位值和只能是9或者18\(例如47的位值和是11，我们将11从47减去之后，得到36，它的位值和就是9\)。在第5步你肯定会得到90\(9 × 10或18 × 5\)。最后90 – 15 = 75。

        舍九法同样对乘法有效。让我们看看将前面的例子改成乘法后是什么结果。

![](.gitbook/assets/image%20%2826%29.png)

       基于FOIL我们可以找到舍九法对乘法有效的原因。根据我们最后一个例子，我们知道数字根是一个数和9的倍数的差值。因此相乘两因数分别可转化成9x + 5 和 9y + 6，这里我们不需要知道x和y的具体值。我们将两因数相乘得到：

\(9x + 5\)\(9y + 6\)  =  81xy + 54x + 45y + 30

                            =  9\(9xy + 6x + 5y\) + 30

                            =  9的倍数 + \(27 + 3\)

                            =  9的倍数 + 3

       舍九法通常不被用于检查除法的结果，但我无法抗拒向你展示一个不可思议的除以9的方法。这一方法有时也会被称为“印度算法”。

12302 ÷ 9

       将其列成竖式

![](.gitbook/assets/image%20%2835%29.png)

       现在将最高位记在横线上，将R记在最低位上。

![](.gitbook/assets/image%20%2831%29.png)

       接着如下图所示，将对角线上的数字相加。对角线上圈出的数是1和2，和是3。所以我们在第二位上记3。

![](.gitbook/assets/image%20%2823%29.png)

        接着3+3=6。

![](.gitbook/assets/image%20%2832%29.png)

         6+0=6

![](.gitbook/assets/image%20%2836%29.png)

        最后6+2=8是余数

![](.gitbook/assets/image%20%2839%29.png)

        这里的答案是12,302 ÷ 9 = 1366余8。看起来太简单了。让我们在做一个31415 ÷ 9，答案是：

![](.gitbook/assets/image%20%2834%29.png)

        从3开始，我们得到3 + 1 = 4，4 + 4 = 8，8 + 1 = 9，9 + 5 = 14。所以答案是3489余14。但是因为14 = 9 + 5，我们给商加一，新的答案是3490余5。

        这里有一个很简单的问题，答案很有意思。我把它留给你去解。

        111,111 ÷ 9 = 12,345 R 6

        我们看到当余数是9或者更大时，我们为商加1，将余数减去9。在我们计算商的每一位时，我们也会遇到类似的情况。此时，我们标记下进位，接着把和减去9，然后继续下一位。例如4821 ÷ 9。

![](.gitbook/assets/image%20%2830%29.png)

       我们从4开始，4 + 8 = 12，我们在4上面标记下进位，然后从12中减去9得到下一位3。接着是3 + 2 = 5，5 + 1 = 6。结果是商535余6。

![](.gitbook/assets/image%20%2824%29.png)

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg)   
        这里是一个具有多个进位的例子，98,765 ÷ 9。

![](.gitbook/assets/image%20%2822%29.png)

        从9开始，我们计算9 + 8 = 17，标明进位并减去9，所以商的第二位是8。下一步8 + 7 = 15，标明进位并减去9，商的第三位是6。6 + 6 = 12，标明进位，商的第四位是3。最后余数是3 + 5 = 8。将所有的进位计入商，得到最终的结果是10,973 余8。

{% hint style="info" %}
  
如果你觉得除以9很酷，看看除以91。要求对任意两位数，你可以立即将其除以91，且商的精度可以达到任意长度。不是开玩笑，不用纸笔你就可以做到。例如

53 ÷ 91 = 0.582417 . . .

更特别的是答案是 $$0.\overline{582417}$$ 上面的横线表明这些数将无限循环。这些数是从那来的呢？如同两位数乘以11一样简单。使用第一章介绍过的知识，我们知道53 × 11 = 583。将此数减去1，我们得到答案的前半部分0.582。答案的后一半是999减去前一半，999 − 582 = 417。这样正如承诺的一样，我们的答案是$$0.\overline{582417}$$。

让我们多举一些例子。试试78 ÷ 91。78 × 11 = 858，所以答案的前半部分是857。接着999 − 857 = 142算出后半部分。答案是 $$0.\overline{857142}$$ 。我们在第一章已经见过这个数，因为78/91 可约分成6/7。

这一方法有效是因为91×11=1001。这样在第一个例子中 $$\frac{53}{91}=\frac{53\times11}{91\times11}=\frac{583}{1001}$$ 。既然![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)，我们得到结果中循环的部分583 × 999 = 583,000 − 583 = 582,417。

因为91 = 13 × 7，我们便可通过一个优雅方法求一个数除以13的商。我们可以将除数变成91，比如 $$\frac{1}{13} = \frac{7}{91}$$ ，因为7 × 11 = 77，我们得到 $$\frac{1}{13}=\frac{7}{91}=0.\overline{076923}$$ 。同样的， $$\frac{2}{13}=\frac{14}{91}=0.\overline{153846}$$ 。
{% endhint %}

## 10、11、12的魔力和模算术

        我们已经学到的关于9的很多知识都可以延伸到其它的数。舍九法中，我们实际是用除以9的余数来代替一个数。对大多数人来说，用余数来替换初始数并不新鲜。自从我们学会了如何辨别时间，我们一直在做同样的事。譬如，如果一个钟显示8点（不管早上还是晚上），那么3个小时后显示什么时间呢？15小时后呢？27小时后呢？9小时之前呢？虽然你的第一反应可能是说，时间可能是11或23或35或1，但对时钟而言，所有这些都是11点，因为所有这些时间的差是12的倍数。数学家们使用的符号是

        11 ≡ 23 ≡ 35 ≡ −1 \(mod 12\)

![](.gitbook/assets/image%20%2825%29.png)

        一般说，如果a和b的差值是12的倍数，我们说 a ≡ b \(mod 12\) 。等价的，如果a和b除以12有相同的余数，我们说 a ≡ b \(mod 12\) 。更一般的，对任意正整数m，如果a和b的差是m的倍数，我们说a和b模相等，记为a ≡ b \(mod m\)。相当于

        _**对整数q，如果a = b + qm，则a ≡ b \(mod m\)** 。_

        同余的好处是它们的行为几乎和普通等式一样。我们可以通过加减乘除对其实现模运算。譬如，如果a ≡ b \(mod m\)，对任意整数c，下面等式成立

        a + c ≡ b + c and ac ≡ bc \(mod m\)

        不同的同余数可以加、减、乘。如果a ≡ b\(mod m\) 而 c ≡ d \(mod m\), 则a + c ≡ b + d 、 ac ≡ bd \(mod m\)。

        例如，因为14 ≡ 2 且 17 ≡ 5 \(mod 12\), 则 14 × 17 ≡ 2 × 5 \(mod 12\), 事实上238 = 10 + \(12 × 19\)。这条规律的一个结果是我们可以提出幂的同余性。如果a ≡ b \(mod m\)，我们有这样的乘方原理：

$$
a^2\equiv b^2 \quad a^3\equiv b^3 \ \cdots \ a^n\equiv b^n (mod m)
$$

![&#x6587;&#x672C;&#x6846;: &#x65C1;&#x767D;

&#x4E3A;&#x4F55;&#x6A21;&#x7B97;&#x672F;&#x80FD;&#x591F;&#x6709;&#x6548;&#xFF1F;&#x5982;&#x679C;a &#x2261; b \(mod m\) &#x4E14; c &#x2261; d \(mod m\)&#xFF0C;&#x5219;a = b+ pm&#xFF0C; c = d + qm&#xFF08;p&#x548C;q&#x90FD;&#x6574;&#x6570;&#xFF09;&#x3002;&#x8FD9;&#x6837;a + c = \(b + d\) + \(p + q\)m&#xFF0C;&#x56E0;&#x6B64;a + c &#x2261; b + d \(mod m\)&#x3002;&#x4F7F;&#x7528;FOIL&#x5C55;&#x5F00;&#xFF0C;ac = \(b + pm\)\(d + qm\) = bd + \(bq + pd + pqm\)m&#x3002;
&#x6240;&#x4EE5;ac&#x548C;bd&#x7684;&#x5DEE;&#x503C;&#x662F;m&#x7684;&#x500D;&#x6570;&#xFF0C;ac &#x2261; bd \(mod m\)&#x3002;&#x5C06;&#x6A21;&#x76F8;&#x7B49;&#x7684;&#x4E24;&#x4E2A;&#x6570;a &#x2261; b \(mod m\) &#x540C;&#x65F6;&#x4E58;&#x65B9;&#x5F97;a2 &#x2261; b2 \(mod m\)&#xFF0C;&#x4E0D;&#x505C;&#x7684;&#x4E58;&#x4EE5;&#x81EA;&#x5DF1;&#x5219;&#x5F97;&#x5230;&#x6211;&#x4EEC;&#x7684;&#x4E58;&#x65B9;&#x89C4;&#x5219;&#x3002;


](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image047.png)  
 

{% hint style="info" %}
  
为何模算术能够有效？如果a ≡ b \(mod m\) 且 c ≡ d \(mod m\)，则a = b+ pm， c = d + qm（p和q都整数）。这样a + c = \(b + d\) + \(p + q\)m，因此a + c ≡ b + d \(mod m\)。使用FOIL展开，ac = \(b + pm\)\(d + qm\) = bd + \(bq + pd + pqm\)m。

所以ac和bd的差值是m的倍数，ac ≡ bd \(mod m\)。将模相等的两个数a ≡ b \(mod m\) 同时乘方得 $$a^2 ≡ b^2 (mod m)$$ ，不停的乘以自己则得到我们的乘方规则。
{% endhint %}

        正是乘方原理将9变成10进制中如此特殊的一个数。因为10 ≡ 1 \(mod 9\)。

        根据乘方原理，对任意整数n， $$10^n ≡ 1^n = 1 (mod 9) $$ 。这样像3456满足

3456  =  3\(1000\) + 4\(100\) + 5\(10\) + 6

            ≡  3\(1\) + 4\(1\) + 5\(1\) + 6 = 3 + 4 + 5 + 6  \(mod 9\)

        因为10 ≡ 1 \(mod 3\)，这解释了为何你可以通过求位值和来判断一个数是否是3的倍数（或者除以3的余数是多少）。如果你使用不同的进制，比如16进制（电子工程和计算机科学中常用的进制），因为 16 ≡ 1 \(mod 15\)，你可以通过求位值和来判断一个数是否是15（3或5）的倍数，或者判断一个数除以15的余数。

        返回十进制。有一个优雅的方法可判断一个数是否是11的倍数。它基于10 ≡ -1 \(mod 11\)。

        进而10n ≡ \(−1\)n \(mod 11\)。这样102 ≡ 1 \(mod 11\)，103 ≡ \(−1\) \(mod 11\)等等。例如3456满足

3456   =  3\(1000\) + 4\(100\) + 5\(10\) + 6

            ≡  −3 + 4 − 5 + 6 = 2  \(mod 11\)

        3456除以11的余数是2。一般的规则是，一个数是11的倍数，当且仅当它的各位依次加减后的结果是11的倍数。例如，31415是11的倍数吗？我们对各位依次加减3 − 1 + 4 − 1 + 5 = 10，我们得出结论它不是11的倍数。但是如果我们考虑31416，各位加减后的结果是11，所以31416是11的倍数。

        模11运算实际上被用于创建和验证ISBN（International Standard Book Number）编号。假设你的一本书有10位的ISBN编号（2007年之前出版的大多数书如此）。前几位数字代表书籍的原籍国，出版商和标题，但是第10位（被称为校验位）是为满足特殊的数字关系。确切地说，如果这个10位数看起来像a-bcd-efghi-j，则选择j是为了满足

10a + 9b + 8c + 7d + 6e + 5f + 4g + 3h + 2i + j ≡ 0 \(mod 11\)

        例如，我们的书《心算的秘密》（Secrets of Mental Math）出版在2006年，ISBN编号是0-307-33840-1, 带入上面的公式

10\(0\) + 9\(3\) + 8\(0\) + 7\(7\) + 6\(3\) + 5\(3\) + 4\(8\) + 3\(4\) + 2\(0\) + 1 = 154 ≡ 0 \(mod 11\)

        你可能会好奇，如果校验位是10该怎么办。在这种情况下使用X，它在罗马数字中表示10。ISBN系统有个有点是：如果其中一位数字出错，系统可以检测到。假如第三位数字错了，那么最后的总数将偏差8的倍数，±8、±16 . . . ± 80。但是所有这些数中，没有11的倍数（11是一个质数），因而新的总和不会是11的倍数。事实上，利用一点代数知识，我们也可以知道该系统也可以探测到两个数位的错位。假如c和f错位，其余都正确。这样全部影响来自于c和f的偏差。原先的8c + 5f变成了8f + 5c，差值是 \(8f + 5c\) − \(8c + 5f\) = 3\(f − c\)，它不是11的倍数。这样新的总数将不是11的倍数。

        2007年，出版社转向ISBN-13系统，该系统使用13位编码，基于模10算法而不在是模11。新系统下，编号abc-d-efg-hijkl-m 仅在满足以下算式时才有效

a + 3b + c + 3d + e + 3f + g + 3h + i + 3j + k + 3l + m ≡ 0 \(mod 10\)

        例如本书的ISBN-13编号是978-0-465-05472-5。一个快速验证此编号的方法是将奇偶位分开计算

\(9 + 8 + 4 + 5 + 5 + 7 + 5\) + 3\(7 + 0 + 6 + 0 + 4 + 2\) = 43 + 3\(19\) = 43 + 57 = 100 ≡ 0 \(mod 10\)

        ISBN-13系统将检测到任何一位数的错误和大多数（不是全部）相邻位的错位。比如，最后一个例子中，如果最后三位由725变成了275，则该错误无法被检测到。因为新的总和110仍然是10的倍数。类似的模10系统被用于验证条形码、信用卡和借记卡号。模算术在电子线路和互联网安全设计中也起着重要的作用。  


## 日历计算

        我最喜欢的数学派对戏法是，根据生日信息，推测一个人的生日是一周的哪一天。 例如，如果有人告诉你她是在2002年5月2日出生的，你可以立即说出她是在星期四出生的。 更实用的技能是能够计算当前或即将到来的一年中任何日期是一周中的哪一天。 在本节中，我将向你介绍它的一个简单方法，以及它背后的数学。

        但是在我们深入研究这个方法之前，我们有必要回顾一下日历背后的一些科学历史背景。因为地球绕太阳一周需要365.25天，一个典型的年份有365天，但是我们每四年增加一个闰日，2月29日（这样每四年有4 × 365 + 1 = 1461天，总量上是正确的）。这是尤里乌斯·凯撒两千年前建立儒略历背后的想法。例如，2000年是闰年，之后每四年出现一次闰年：2004、2008、1012、2016，直到2096。但是2100不是闰年，为什么呢？

        问题是，一年实际上的时间是大约365.243天（大约比365.25少11分钟），所以闰年被略微的多算了。地球绕行太阳四百次，我们经历了146,097天，但儒略历为此分配了400×365.25 = 146,100天（日历上多出三天）。为避免这个问题（以及其它与复活节相关的困难），罗马教皇格里高利十三世与1582年建立了格里历。那一年，天主教国家从他们的日历中移除了十天。 例如，在西班牙，1582年10月4日星期四（儒略日期）之后是公元1582年10月15日星期五（格里历日期）。根据格里历，可以被100整除的年份不再是闰年，除非他们也可以被400除尽（因此消除三天）。因此，1600年仍然是格里历的闰年，但1700年，1800年和1900年不会是闰年。 同样，2000年和2400年是闰年，但2100年，2200年和2300年不是闰年。 在这个制度下，在任何四百年里，闰年的数量是100 - 3 = 97，因此根据需要的天数将是（400×365）+97 = 146,097。

        格里历并未被所有国家立即接受，非天主教国家采用它的速度特别慢。例如，英格兰及其殖民地直到1752年9月2日星期三才开始转换，后一天是9月14日星期四（注意，11天被淘汰，1700年是儒略历上的闰年，但不是在格里历中）。直到20世纪20年代，所有国家都从儒略历转换到了格里历。这一直是历史学复杂的原因。我最喜欢的历史矛盾是，威廉莎士比亚和米格尔塞万提斯于1616年4月23日同一天死亡，但事实上他们相隔十天。这是因为当塞万提斯去世时，西班牙已经转换为格里历，但英格兰仍然在儒略历上。因此，当塞万提斯于公元1616年4月23日逝世时，英格兰是1616年4月13日，莎士比亚仍然活着（不过只有10天的阳寿了）。

        用来判断格里历中的日期是星期几的公式为：

        星期几 = 月代码 + 日期 + 年代码（mod 7）

        我们很快会解释公式中所有的项。 这个公式使用了模7运算，因为每周有7天。例如，如果日期是未来72天，那么它与两天后具有相同的星期几，因为72 ≡ 2（mod 7）。或者距离28天的两天将是一周中的同一天，因为28是7的倍数。

{% hint style="info" %}
  
那么，星期几的名字来自哪里呢？ 以太阳，月亮和五个最接近的天体命名一周中的每一天都习俗可以追溯到古代的巴比伦。 从太阳，月亮和土星，我们立即得到星期日，星期一和星期六。 其他名称更容易在法文或西班牙文中看到。 例如，火星变成狂欢节或殉道者; Mercury成为Mercredi或Miércoles; 木星变成了Jeudi或Jueves; 金星成为Vendredi或Viernes。 请注意，火星，水星，木星和金星也是罗马神和女神的名字。 英语具有日耳曼语的起源，早期的德国人将这些日子的一些改名为北欧神。 所以火星变成了Tiw，水星变成了Woden，木星变成了Thor，金星变成了Freya，这就是我们星期二，星期三，星期四和星期五的名字。
{% endhint %}

| **编号** | **星期几** |
| :--- | :--- |
| **1** | 星期一 |
| **2** | 星期二 |
| **3** | 星期三 |
| **4** | 星期四 |
| **5** | 星期五 |
| **6** | 星期六 |
| **7或0** | 星期天 |

        下面是每月的代码

| **月份** | **代码** |
| :--- | :--- |
| 一月 | 6 |
| 二月 | 2 |
| 三月 | 2 |
| 四月 | 5 |
| 五月 | 0 |
| 六月 | 3 |
| 七月 | 5 |
| 八月 | 1 |
| 九月 | 4 |
| 十月 | 6 |
| 十一月 | 2 |
| 十二月 | 4 |

        随后我会解释这些数是如何得出的，但我希望你先学习如何执行计算。 现在，你需要知道的唯一年份代码是2000年的代码为0。让我们使用这些信息来确定当年3月19日（我的生日）是星期几。 由于3月份的月份代码为2，而2000年的年份代码为0，那么我们的公式告诉我们，2000年3月19日，

        星期几 = 2 + 19 + 0 = 21 ≡ 0 \(mod 7\)

        这样，2000年3月19日是星期天。  


{% hint style="info" %}
  
以下是月份代码来自哪里的快速解释。请注意，在非闰年中，2月和3月的月份代码是相同的。这是有道理的，因为二月有28天，那么3月1日是2月1日后的第28天，所以两个月都会在一周的同一天开始。现在正好是2000年3月1日，是一个星期三。因此，如果我们想给2000年一个年代码0，并且我们希望星期一的代码为1，那么这会迫使3月份的月份代码为2。因此，如果它不是闰年，那么2月份必须有一个也是2的代码！而且由于3月有31天，这比3月28日更大，所以4月日历进一步移动了3天，这就是为什么它的月份代码是2 + 3 = 5。而当我们添加4月的28 + 2日到5的月份代码，我们看到5月份必须有5 + 2 = 7的月份代码，因为我们正在使用模 7，所以可以减少到0。继续这个过程，我们可以确定一年中余下的月份代码。

另一方面，在闰年（如2000年）中，2月有29天，所以3月日历将比2月的日历提前一天，这就是为什么2月份的月份代码在闰年为2 - 1 = 1。1月有31天，所以它的月份代码必须低于2月份的月份代码。因此，在非闰年中，1月的月份代码将为2 - 3 = -1 ≡ 6\(mod 7\)。在闰年中，1月的月份代码将为1 - 3 = -2 ≡ 5\(mod7\)。
{% endhint %}

        年复一年，你的生日会发生什么？通常情况下，你的两个生日间隔365天，当这种情况发生时，你的生日的在一周中会往后移动一天，因为365 = 52 × 7 + 1，即365 ≡ 1\(mod 7\)。但是当你的两个生日间出现2月29日（假设你不是2月29日出生的），那么你的生日在一周中会移动两天。在我们的公式中，除了闰年要加2，我们只需为其余年份代码加1即可。 以下是2000年至2031年的年份代码。不要担心。 你不需要记住这个！

| **年** | **代码** | **年** | **代码** | **年** | **代码** | **年** | **代码** |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 2000\* | 0 | 2008\* | 3 | 2016\* | 6 | 2024\* | 2 |
| 2001 | 1 | 2009 | 4 | 2017 | 0 | 2025 | 3 |
| 2002 | 2 | 2010 | 5 | 2018 | 1 | 2026 | 4 |
| 2003 | 3 | 2011 | 6 | 2019 | 2 | 2027 | 5 |
| 2004\* | 5 | 2012\* | 1 | 2020\* | 4 | 2028\* | 0 |
| 2005 | 6 | 2013 | 2 | 2021 | 5 | 2029 | 1 |
| 2006 | 0 | 2014 | 3 | 2022 | 6 | 2030 | 2 |
| 2007 | 1 | 2015 | 4 | 2023 | 0 | 2031 | 3 |

2000至2031年的年代码，\*表明是闰年

        注意年代码是如何从0、1、2、3开始，2004年是闰年，所以年代码变成5。接着2005年的年代码是6，2006年的年代码是7，但是由于我们在模7，因此年代码是0。这样2007的年代码是1。2008年是闰年，所以年代码是3。使用这个年代码表，你能够断定2025，π day（3月14日）将是

2 + 14 + 3 = 19 ≡ 5 \(mod 7\) =星期五

        2008年1月1日是星期几呢？注意2008年是闰年，所以1月的月代码是5而不是6。因此，我们得到

5 + 1 + 3 = 9 ≡ 2 \(mod 7\) = 星期二

        注意，当你读年代码表时，你会发现每一列增加8年，年代码增加3。比如，第一列的年代码0、 3、6、2（2等于9 \(mod 7\)）。这是因每隔8年，日历会经历两个闰年，所以日期会移动8 + 2 = 10 ≡ 3 \(mod 7\)天。

        更好的消息是： 在1901年和2099年之间，日历将每28年重复一次。 为什么？ 28年中，我们定然会经历7次闰年，所以日历将会移动28 + 7 = 35天，这使得一周中的每一天都不变，因为35是7的倍数（如果28年跨越1900年或2100年，这种说法就完全正确了，因为这些年就不是闰年）。因此，通过增加或减少28的倍数，可以将1901年和2099年之间的任何年份变成2000年到2027年之间的一年。例如，1983年 具有与1983 + 28 = 2011年相同的年份代码。2061年具有与2061-56 = 2005年相同的年份代码。

        因此，出于实用目的，你可以将任何一年转换为此表中的某一年，并且可以很容易地计算出这些年份代码。 例如，为什么2017年的年份代码为0？ 好吧，因为2000年的年份代码为0，日历已经转移了17次后，经历了4次闰年2004、2008、2012和2016。因此2017年的年份代码是17 + 4 = 21 ≡ 0\(mod7\)。 2020年如何？ 这次我们有5次闰年转换（包括2020年），所以日历转换20 + 5 = 25次，25 ≡ 4（mod 7）。所以，2020年的年份代码为4。一般来说，任何在2000年和2027年之间的年份，你都可以按如下方式确定其年份代码。

* 第1步：取一年的最后两位数字。 例如，在2022年，最后两位数字是22。
* 第2步：将该数除以4，忽略余数。 （这里，22÷4 = 5，余数为2）。
* 第3步：将第1步和第2步中的数加起来。这里，22 + 5 = 27。
* 第4步：将步骤3中的数减去小于它的7的最大倍数（将为0、7、14、21或28）以获得年代码（换句话说，通过模7减少步骤3中的数）。由于27 - 21 = 6，那么2022的年代码是6。

        注意步骤1至步骤4对2000和2099之间的任一年都有效，不过如果你首先通过减去28的倍数将年限制在2000和2027之间，心算起来将更加简单。例如，我们可以先将2040年变为2012年。这样以上第4步的计算就是12 + 3 – 14 = 1。不过，你也可以直接基于2040计算年代码40 + 10 – 49 = 1。

        同样的步骤也适用于2000年之前的年份。 月份代码不会更改。 年份代码只有一个小调整。1900年的年代码为1。因此，1900和1999之间的年代码较之2000到2099大1。2040的年份代码为1，那么1940的年代码为2。 2022的年代码为6，那么1922的年代码为7（或者等于0）。1800的年代码为3，1700的年代码为5，1600的年代码为0（事实上，日历每四百年就会循环一次，因为在400年内它将会有100 - 3 = 97个闰年，从现在起400年后，日历将转换400 + 97 = 497天，这与今天相同，因为497是7的倍数）。

        1776年7月4日是星期几？为了找到2076年的年代码，我们先减去56，接着计算2020年的年代码：20 + 5 – 2 = 4。这样1776年的年代码是4 + 5 = 9 ≡ 2 \(mod 7\)。这样，格里历的1776年7月4日是：

5 + 4 + 2 = 11 ≡ 4 \(mod 7\) = 星期四

        也许“独立宣言”的签署人需要在长假期前迅速通过立法？

{% hint style="info" %}
  
让我们以9的另外一个神奇属性结束本章。任取一个从高位到低位依次增大的数。比如，12345、2358、369或135789。将这个数乘以9，然后将所有位上的数字加起来。虽然我们知道位值之和是9的倍数，但是令人吃惊的是位值和总是9。例如，

9 × 12345 = 11,1059 × 2358 = 21,2229 × 369 = 3321

即使出现了重复的数字，只要位值是增大的并且个位一定比十位大，则该规律依然成立。比如：

9 × 12223 = 110,0079 × 33344449 = 300,100,041

为什么是这样呢？让我们看看当ABCDE（A ≤ B ≤ C ≤ D &lt; E）乘以9时发生了什么。因为乘以9等同于乘以（10-1），这就等同于一个减法问题 ![](.gitbook/assets/image%20%2838%29.png) 

如果我们从左往右做这个减法，由于B ≥ A 、C ≥ B、D ≥ C和E &gt; D，这就成为了 ![](.gitbook/assets/image%20%2828%29.png) 

答案的位值和就是

A + \(B − A\) + \(C − B\) + \(D − C\) + \(E − D − 1\) + \(10 − E\) = 9

和我预期的一致。
{% endhint %}

