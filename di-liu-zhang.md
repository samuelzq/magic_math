# 第六章

  


1 + 2 + 3 = 1 × 2 × 3 = 6

## 证明的魔力

**证明的价值**

数学的巨大乐趣之一，实际上也是将数学与其他学科分开的能力，就是明确无误地证明事物真实性的能力。在其他学科中，我们接受某些规则是因为它们符合我们对现实世界的观察结果，但是如果有新的证据出现，这些规则可能会被否定或修改。但是在数学中，如果一个陈述被证明是真实的，那么它将永远是真的。例如，二千年前欧几里得证明，有无限多的素数，而且我们能说或做的任何事情都不会与该声明的真实性相矛盾。技术不断跟新，但定理永恒。正如伟大的数学家哈代（G.H.Hardy）所说：“一位数学家，像画家或诗人一样，是模式的制造者。如果数学家的模式更持久，那是因为它们是有思想的。”对我来说，证明一个新的数学定理似乎是通往学术不朽的最佳途径。

数学不仅能以绝对的确定性来证明事物，还能证明某些事情是不可能的。有时人们会说：你无法证明一个否定的观点。这就如同你无法证明不存在紫色的奶牛一样，因为也许某一天会出现一头紫色的奶牛。但是数学就可以证伪。例如，无论你怎么尝试，你都将无法找到和为奇数的两个偶数，或者一个最大的质数。当你第一次（或者第二次、第三次）遇到证明的时候，它可能对你来说有点可怕，但是它绝对值得慢慢品味。一旦你掌握了其中的窍门，你就可以很好的阅读和写作。好的证明就似一个讲得很好的笑话或者故事，它会让你在结尾处感到满意。

让我告诉你我第一次证明不可能的经历。当我还是个孩子的时候，我喜欢游戏和拼图。一天，有个朋友用一个拼图游戏向我挑战。当然，我也很感兴趣。他给我看了一个8 × 8的空棋盘，并拿出32个标准的1 × 2多米诺骨牌。他问：你能将这32块多米诺骨牌铺满整个棋盘吗？我说：当然可以。每行4块就行了。

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

铺满多米诺骨牌的8 × 8棋盘

“很好。”他说，“假如现在我将棋盘左上角和右下角的正方形排除掉。”他在这两个格子中分别放入一枚硬币，这样我就不能将多米诺骨牌铺在相应的格子中。“现在你能用31块多米诺骨牌铺满这62个正方形吗？”

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

当角上两个格被移除后，多米诺骨牌还能铺满棋盘吗？

“也许我可以，”我说。但是，无论我怎么尝试，我都无法成功。我开始认为这是无法完成的任务。

“如果你认为它是无法完成的，你能够证明吗？”我的朋友问道。如果不穷尽所有可能的失败，我将如何证明呢？他提示说：“请看看棋盘上格子的颜色。”

棋盘的颜色？它和这个问题有什么关系呢？我开始检查棋盘的颜色。因为移除的两个格子都是浅色的，棋盘上剩下32个深色的格子和30个浅色的格子。而每个多米诺骨牌都要占据一个深色和一个浅色格子。所以，现在的情况下，31个多米诺骨牌根本无法铺满棋盘。好酷啊！

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p>&#x5982;&#x679C;&#x4F60;&#x559C;&#x6B22;&#x521A;&#x521A;&#x7684;&#x8BC1;&#x660E;&#xFF0C;&#x4F60;&#x5C06;&#x4E5F;&#x4F1A;&#x559C;&#x6B22;&#x63A5;&#x4E0B;&#x6765;&#x8FD9;&#x4E2A;&#x3002;&#x4FC4;&#x7F57;&#x65AF;&#x65B9;&#x5757;&#x4F7F;&#x7528;7&#x79CD;&#x4E0D;&#x540C;&#x7684;&#x79EF;&#x6728;&#xFF0C;&#x6709;&#x65F6;&#x5019;&#x5206;&#x522B;&#x88AB;&#x8BB0;&#x4E3A;I&#x3001;J&#x3001;L&#x3001;O&#x3001;Z&#x3001;T&#x548C;S&#x3002;</p>
        <p>
          <img src="file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg"
          alt/>
        </p>
        <p>&#x8FD9;7&#x5757;&#x79EF;&#x6728;&#x80FD;&#x7EC4;&#x6210;&#x4E00;&#x4E2A;4
          &#xD7; 7&#x7684;&#x77E9;&#x5F62;&#x5417;&#xFF1F;</p>
        <p>&#x6BCF;&#x5757;&#x79EF;&#x6728;&#x6B63;&#x597D;&#x6709;4&#x4E2A;&#x6B63;&#x65B9;&#x5F62;&#xFF0C;&#x6240;&#x4EE5;&#x4EBA;&#x4EEC;&#x5F88;&#x81EA;&#x7136;&#x4F1A;&#x60F3;&#xFF0C;&#x80FD;&#x5426;&#x628A;&#x5B83;&#x4EEC;&#x6392;&#x6210;&#x4E00;&#x4E2A;4
          &#xD7; 7&#x7684;&#x77E9;&#x5F62;&#xFF1F;&#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x4E0D;&#x53EF;&#x80FD;&#x7684;&#x6311;&#x6218;&#x3002;&#x4F60;&#x5C06;&#x5982;&#x4F55;&#x8BC1;&#x660E;&#x5462;&#xFF1F;&#x5982;&#x4E0B;&#x56FE;&#xFF0C;&#x4E3A;4
          &#xD7; 7&#x77E9;&#x5F62;&#x4E2D;&#x7684;&#x5355;&#x5143;&#x683C;&#x6D82;&#x4E0A;&#x5F88;&#x767D;&#x76F8;&#x51CF;&#x7684;&#x989C;&#x8272;&#x3002;</p>
        <p>
          <img src="file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg"
          alt/>
        </p>
        <p>&#x6CE8;&#x610F;&#xFF0C;&#x9664;&#x4E86;&#x79EF;&#x6728;T&#xFF0C;&#x5176;&#x4F59;&#x79EF;&#x6728;&#x65E0;&#x8BBA;&#x6446;&#x653E;&#x5728;&#x4EC0;&#x4E48;&#x4F4D;&#x7F6E;&#xFF0C;&#x90FD;&#x5C06;&#x5360;&#x636E;&#x4E24;&#x4E2A;&#x9ED1;&#x8272;&#x548C;&#x4E24;&#x4E2A;&#x767D;&#x8272;&#x683C;&#x5B50;&#x3002;&#x79EF;&#x6728;T&#x4E2D;&#x603B;&#x662F;&#x6709;&#x4E00;&#x5757;&#x79EF;&#x6728;&#x548C;&#x5176;&#x4F59;&#x4E09;&#x5757;&#x79EF;&#x6728;&#x7684;&#x989C;&#x8272;&#x4E0D;&#x540C;&#x3002;&#x8FD9;&#x6837;&#xFF0C;&#x65E0;&#x8BBA;&#x5176;&#x4F59;&#x516D;&#x5757;&#x79EF;&#x6728;&#x5982;&#x4F55;&#x6446;&#x653E;&#xFF0C;&#x90FD;&#x5C06;&#x6709;12&#x4E2A;&#x767D;&#x8272;&#x548C;12&#x4E2A;&#x9ED1;&#x8272;&#x683C;&#x5B50;&#x88AB;&#x5360;&#x636E;&#x3002;&#x8FD9;&#x6837;&#x5C31;&#x53EA;&#x5269;&#x4E0B;2&#x4E2A;&#x767D;&#x8272;&#x548C;&#x4E24;&#x4E2A;&#x9ED1;&#x8272;&#x7684;&#x683C;&#x5B50;&#xFF0C;&#x800C;&#x65E0;&#x8BBA;&#x5982;&#x4F55;&#x90FD;&#x4E0D;&#x80FD;&#x7EC4;&#x6210;&#x79EF;&#x6728;T&#x3002;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

如果我们认为一个数学声明正确后，我们该如何说服自己呢？通常，我们首先对这些数学对象进行描述，比如整数集合包含：负整数、正整数和零。

. . . ，−2，−1，0，1，2，3，. . .

一旦我们描述了某个数学对象，我们会对它的我们认为不言自明的属性做出假设，比如“两个整数的积还是整数”。在下一章，我们将做出几何假设如“两点之间可以做出一条直线”。这些不言自明的声明被称为公设或公理。基于这些公设，运用一些逻辑和代数，我们能推导并证明出别的声明，它们被称为定理。定理往往不是那么显而易见的。在本章中，你将学到数学证明的基本工具。

让我们先来证明一些容易相信的定理。当我们第一次听到类似“两个偶数之和是偶数”、“两个奇数的积是奇数”的声明时，我们通常会在脑海中验证几个实例。接着判定这一声明是否正确或合理。你甚至会认为，这些话是不言自明的，我们可以让它成为公理。但是我们不必如此，因为我们可以使用已知的公理证明它。要证明一个数是奇数或偶数，我们必须首先知道什么是奇数和偶数。

偶数是2的倍数。用代数方法来描述，如果n是一个偶数，则n = 2k，其中k是一个整数。0是不是一个偶数呢？是的，因而0 = 2 × 0。我们现在准备证明两个偶数之和是一个偶数。

**定理：**如果m和n都是偶数，则m + n也是一个偶数。

这是一个“如果……则”定理。要证明这样一个声明，我们先通常假定“如果”部分，通过逻辑和代数的组合揭示“则”部分的是由假设部分推导而来。这里，我们假定m和n都是偶数，并想得出m + n也是偶数的结论。

**证明：**假设m和n都是偶数。这样，m = 2j、n = 2k，其中j和k都是整数。

m + n = 2j + 2k = 2\(j + k\)

既然j和k都是整数，j + k也是整数。m + n既然是2的倍数，则肯定是一个偶数。

□

注意这个证明依赖于公理：两个整数之和（j + k）肯定是一个整数。当你证明更复杂的声明时，你更可能要依赖于之前已经证明的定理而不是公理。数学家们通常会用符号□或■或Q.E.D记在证明最后一行的右边，以表示证明的完结。Q.E.D. 是拉丁语 “quod erat demonstrandum” 的缩写（有人将其改写为“quite easily done”），意思是”证明完毕“。如果我认为一个证明特别优雅，我将以一个笑脸☺来结束。

在证明了这个“如果……则”定理之后，数学家们忍不住想要知道将“如果”和“则”颠倒之后，相反说法的真实性。这里，相反的说法是“如果m + n是偶数的话，则m和n都是偶数”。通过提出反例，很容易证明这个声明是不对的。对这个声明，一个反例是

1 + 1 = 2

这个例子显示两个奇数的和也是一个偶数。

我们下一个定理是关于奇数的。奇数不是2的倍数。因此，当奇数被2除时，我们总是得到余数1。用代数方式描述，如果n = 2k + 1，k是一个整数，则n是一个奇数。这允许我们使用简单的代数证明两个奇数的积还是一个奇数。

**定理**：如果m和n是奇数，则mn也是奇数。

**证明**：假设n和m都是奇数。则m = 2j + 1 、n = 2k + 1，其中j和k是整数。这样根据FOIL原理

mn = \(2j + 1\)\(2k + 1\)= 4jk + 2j + 2k + 1 = 2\(2jk + j + k\) + 1

因为2jk + j + k是整数，所以mn是“一个整数的两倍+1”，即为一个奇数。

□

逆命题“如果mn是奇数，则m和n都是奇数”是否成立呢？这个命题也成立。我们可用反证法来证明它。反证法中，我们证明拒绝结论（本例中，结论是m和n都是奇数）将导致矛盾。特别的是，如果我们拒绝结论，我们的假设不成了，所以逻辑上结论肯定是正确的。

**定理**：如果mn是奇数，则m和n都是奇数。

**证明**：假设，m或n至少有一个是偶数。其实谁是偶数无关紧要，那就让m是偶数，这样对某一个整数j有m = 2j。这样两数之积 mn = 2jn是一个偶数，这和我们的假设矛盾。

□

如果一个命题和它的逆命题都是真的，数学家们称之为“当且仅当定理”。我们刚刚证明的就是

**定理**：当且仅当mn是奇数时，m和n都是奇数。  


有理数和无理数

刚刚展示的证明可能不会令你惊讶，毕竟它们的证明过程相当简单。当我们证明不那么直观的定理时，有趣的事情就开始了。到目前为止，我们主要讨论的是整数，但现在是时候学习分数了。**有理数**是可以表述为分数的数。更准确地说，如果r = a/b，其中a和b都是整数，且b ≠ 0，则r是有理数。有理数包括，如23/58、-22/7、42 \(42/1\)。有理数之外的数被称为无理数。你也许听说过π = 3.14159……这是一个无理数，我们将在第8章讨论它。

对于下一个定理，回忆一下分数加法是有帮助的。两个具有相同分母的分数比较容易相加。例如

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)

否则的话，我们需要首先使相加的分数具有相同的分母。例如：

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)

总之，通过如下所示，将分母转化为公分母，我们可以将任意分数相加。

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)

我们现在准备证明关于有理数的一个简单事实。

**定理**：两个有理数的平均数仍然是一个有理数。

**证明**：令x和y是两个有理数。这样存在整数a、b、c、d使得x = a/b 、y = c/d。x和y的平均值是

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)

其中分子部分和分母部分都是整数。因此x和y的平均值仍然是一个有理数。

让我们想想这个定理说了什么。它说，对于任意两个有理数，即使它们真的非常接近，我们仍然能够在它们之间找到另一个有理数。你大概会得出结论所有的数都是有理数（正如古希腊人一度相信的一样）。但是，令人吃惊的是，事实并非如此。让我们想想![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)，它的小数表示为 1.4142 . . . . 。目前有很多种用分数近似描述它的方法。例如，10/7 或1414/1000，但它们都不是真正的![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)。也许我们还不够努力？接下来的定理说这样的搜索是徒劳的。这个证明——一个关于无理数的定理，使用的是反证法。在下面的证明中，我们将利用这样一个事实：每个分数都可以被约分，直到分子和分母没有大于1的公约数。

**定理**：![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png) 是无理数

**证明：**假设![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)是有理数，那么必然存在整数a、b（这里a和b没有大于1的公约数）使得![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png)。

如果我们对等式两边同时平方，我们得

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png)

等价于

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image024.png)

这意味着a2是一个偶数。如果a2是偶数，则a必须是一个偶数（我们之前已经证明了，如果a是奇数，a乘以它自己还是一个奇数）。这样a = 2k，其中k为一个整数。将2k代入等式。

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image026.png)

即

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png)

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image030.png)

b2也是一个偶数。进而b是一个偶数。但是等一下！我们证明了a、b都是偶数，这就和a、b没有大于1的公约数相矛盾了。既然假设是有理数导致了矛盾，我们被迫得出结论： 是无理数。

☺

我真得很爱这个证明（笑脸已经证明了），因为它利用纯逻辑的力量证明了一个非常令人吃惊的结果。我们将在第12章看到，无理数并不罕见。事实上，几乎所有的实数都是无理数，虽然我们日常生活中最常打交道的是有理数。

之前的定理有一个有趣的推论（推论是根据早期的定理推出的定理）。这个推论利用指数定律：对于任何正数a、b、c，有

\(ab\)c = abc。

例如

\(53\)2 = 56

这很好理解，因为

\(53\)2 = \(5×5×5\) × \(5×5×5\) = 56

**推论**：存在无理数a和b使得ab是有理数。

很酷的是我们现在就可以证明它，虽然我们仅仅知道一个无理数。我们将后面的证明称为存在性证明，因为它将向你证明a和b的存在，而不告诉你它们的值是多少。

**证明**：我们知道![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)是无理数，所以考虑数![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)。这是有理数吗？如果是有理数，则证明完毕。如果不是，则我们有了一个新的无理数，使用指数定律我们得到

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image034.png)

这是一个有理数。

这样无论它是有理数还是无理数，我们都找到了a和b使得ab是有理数。

☺

类似的存在性证明通常很聪明，但有时也有些不令人满意，因为它们并不能告诉你想要的所有信息（顺便说一句，如果你很好奇，![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)是一个无理数，但这超出了本章的范围）。

更令人满意的是构造性证明，它向你展示了如何找到你想要的信息。例如，我们可以证明一个有理数是有限或者循环的（因为在长除过程中，b最终将会再次去除它之前除过的一个数）。但是逆命题成立吗？有限小数肯定是一个有理数。例如0.12358 = 12,358/100,000。但循环小数是有理数吗？例如0.123123123 ……肯定是一个有理数吗？它是一个有理数，有一个非常聪明的方法可以找到它是什么有理数。让我们给我们的这个神秘数起个名字譬如w，

w = 0.123123123 ……

等式两边同时乘以1000

1000w = 123.123123123 ……

从第二个等式中减去第一个等式

999w = 123

这样

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image036.png)

让我们试一下另一个循环小数，这个循环小数不是从第一个数字开始循环。0.83333 ……对应的分数是多少？

x = 0.83333……

这样

100x = 83.3333……

10x = 8.3333……

当我们用100x减去10x，小数点之后的数字都消失了。

90x = \(83.3333……\) − \(8.3333……\) = 75

这样![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image038.png)

利用这个过程，我们可以构造性的证明一个数当且仅当它的小数部分是有限或循环时，它是一个有理数。如果一个数的小数部分无限不循环，比如

v = 0.123456789101112131415……

是一个无理数。

归纳法

让我们回头来证明关于正整数的定理。在第一章中，通过观察

 1 = 1

   1 + 3 = 4

     1 + 3 + 5 = 9

1 + 3 + 5 + 7 = 16

我们假设并最终证明前n个奇数之和是n2。我们通过一个巧妙的组合来完成这个任务，我们用了两种不同的方法计算棋盘的面积。现在让我们用一个不太聪明的方法来证明它。假设我告诉你前10个奇数之和1 + 3 + · · · + 19是102 = 100，而你不加怀疑地接受了。如果你接受了这一声明，则紧跟着要加上第11个奇数21，总数将会是121 = 112。换句话，前10项的声明的真实性自动隐含了前11项声明的真实性。这就是归纳法的核心思想。我们证明，在开始时包含n的表述是正确的（通常是n = 1时的表述），接着我们证明如果定理在n = k时成立的话，它将在n = k + 1时仍然成立。这样表述对于n的所有值都成立。归纳法有些类似与爬梯子：假设我们证明了你可以爬上梯子，如果你已经爬了一级，你总是能够再爬一级。稍加思考你会相信你可以爬到梯子的任何一级。

例如，对前n个奇数之和，我们的目标是证明对所有n ≥ 1,

1 + 3 + 5 + · · · + \(2n − 1\) = n2

我们看到前1个奇数之和其实就是1 = 12，所以表述在n = 1时成立。下一步，我们注意如果前k个奇数这和是k2，即

1 + 3 + 5 + · · · + \(2k − 1\) = k2

则我们将下一个奇数加上后，将看到

1 + 3 + 5 + · · · + \(2k − 1\) + \(2k + 1\) = k2 + \(2k + 1\)

                                                             = \(k + 1\)2

也就是说，如果前k个奇数之和是 k2，则前k + 1 个奇数之和肯定等于\(k + 1\)2。这样，既然这个定理在n = 1时就成立，它将在n等于任意值时都成立。

□

归纳法是一个强大的工具。我们在这本书中看到的第一个问题是考虑前n个数之和。我们用各种方式证明

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image040.png)

当n = 1时这个表述肯定是对的。如果我们假设这个表述对n = k也是对的：

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image042.png)

则n = k + 1时，

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image044.png)  
 ![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image046.png)

这正是之前的方程用k + 1替换n之后的结果。这样如果方程在 n = k时成立（k可以是任意正数），则在 n = k + 1时它依然成立。因此，恒等式适用于所有的正整数n。

□

在本章以及本书的后续章节中，我们将看到更多归纳法的例子。为了进一步巩固它，这里有一首数学家Dane Camp 和 Larry Lesser写的歌。它可以用Bob Dylan的 “Blowin’ in the Wind” 相同的曲调演唱

How can you tell that a statement is true

For every value of n?

Well there’s just no way you can try them all.

Why you could just barely begin!

Is there a tool that can help us resolve

This infinite quand’ry we’re in?

The answer、my friend、is knowin’ induction.

The answer is knowin’ induction!

First you must find an initial case

For which the statement is true,

Then you must show if it’s true for k

Then k + 1 must work too!

Then all statements fall just like dominos do.

Tell me how did we score such a coup?

The answer、my friend、is knowin’ induction.

The answer is knowin’ induction!

If I told you n times、I told you n + 1,

The answer is knowin’ induction!

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p>&#x65C1;&#x767D;</p>
        <p>&#x5728;&#x7B2C;5&#x7AE0;&#xFF0C;&#x6211;&#x4EEC;&#x53D1;&#x73B0;&#x4E86;&#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;&#x4E4B;&#x95F4;&#x7684;&#x4E00;&#x4E9B;&#x5173;&#x7CFB;&#x3002;&#x8BA9;&#x6211;&#x4EEC;&#x770B;&#x770B;&#x5982;&#x4F55;&#x5229;&#x7528;&#x5F52;&#x7EB3;&#x6CD5;&#x6765;&#x8BC1;&#x660E;&#x5176;&#x4E2D;&#x7684;&#x4E00;&#x4E9B;&#x6052;&#x7B49;&#x5F0F;&#x3002;</p>
        <p><b>&#x5B9A;&#x7406;</b>&#xFF1A;&#x5BF9;n &#x2265; 1,</p>
        <p>F1 + F2 + &#xB7; &#xB7; &#xB7; + Fn = Fn+2 &#x2212; 1</p>
        <p><b>&#x8BC1;&#x660E;&#xFF08;&#x5F52;&#x7EB3;&#x6CD5;&#xFF09;&#xFF1A;</b>&#x5F53;
          n = 1&#x3001;&#x6709; F1 = F3 &#x2212; 1,&#x4EE3;&#x5165;&#x5177;&#x4F53;&#x503C;1
          = 2 &#x2212; 1&#xFF0C;&#x9A8C;&#x8BC1;&#x6052;&#x7B49;&#x5F0F;&#x6B64;&#x65F6;&#x6210;&#x7ACB;&#x3002;&#x73B0;&#x5728;&#x5047;&#x8BBE;n
          = k&#x65F6;&#x6052;&#x7B49;&#x5F0F;&#x6210;&#x7ACB;&#xFF0C;&#x5373;</p>
        <p>F1 + F2 + &#xB7; &#xB7; &#xB7; + Fk = Fk+2 &#x2212; 1</p>
        <p>&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x5728;&#x7B49;&#x5F0F;&#x4E24;&#x4FA7;&#x540C;&#x65F6;&#x52A0;&#x4E0A;&#x53E6;&#x4E00;&#x4E2A;&#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;
          Fk+1&#x3002;</p>
        <p>F1 + F2 + &#xB7; &#xB7; &#xB7; + Fk + Fk+1 = Fk+1 + Fk+2 &#x2013; 1</p>
        <p>= Fk+3</p>
        <p>&#x7ED3;&#x8BBA;&#x5F97;&#x8BC1;</p>
        <p>&#x25A1;</p>
        <p>&#x5173;&#x4E8E;&#x6590;&#x6CE2;&#x90A3;&#x5951;&#x6570;&#x7684;&#x5E73;&#x65B9;&#x548C;&#x7684;&#x8BC1;&#x660E;&#x4E5F;&#x76F8;&#x5F53;&#x7B80;&#x5355;&#x3002;</p>
        <p><b>&#x5B9A;&#x7406;&#xFF1A;</b>&#x5F53; n &#x2265; 1,</p>
        <p>F12 + F22 + &#xB7; &#xB7; &#xB7; + Fn2 = FnFn+1</p>
        <p><b>&#x8BC1;&#x660E;&#xFF08;&#x5F52;&#x7EB3;&#x6CD5;&#xFF09;&#xFF1A;</b>&#x5F53;n
          = 1&#x65F6;&#x3001;&#x56E0;&#x4E3A;F2 = F1 = 1&#xFF0C;&#x6240;&#x4EE5;&#x6709;</p>
        <p>F12 = F1F2</p>
        <p>&#x5047;&#x8BBE; n = k&#x65F6;&#x5B9A;&#x7406;&#x6210;&#x7ACB;&#xFF0C;</p>
        <p>F12 + F22 + &#xB7; &#xB7; &#xB7; + Fk2 = FkFk+1</p>
        <p>&#x4E24;&#x4FA7;&#x90FD;&#x52A0;&#x4E0A;Fk+12</p>
        <p>F12 + F22 + &#xB7; &#xB7; &#xB7; + Fk2 + Fk+12 = FkFk+1 + Fk+12</p>
        <p>= Fk+1(Fk + Fk+1)</p>
        <p>= Fk+1Fk+2</p>
        <p>&#x5B9A;&#x7406;&#x5F97;&#x8BC1;</p>
        <p>&#x25A1;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

第一章中，我们注意到“立方数之和是和的平方”。

                         13 = 12

                 13 + 23 = \(1 + 2\)2

         13 + 23 + 33 = \(1 + 2 + 3\)2

 13 + 23 + 33 + 43 = \(1 + 2 + 3 + 4\)2

但是我们没有证明它。我们现在可以用反证法很快地证明它。通用的模式是，对n ≥ 1,

13 + 23 + 33 + · · · + n3 = \(1 + 2 + 3 + · · · + n\)2

因为我们已经知道1 + 2 + 3 + · · · + n = n\(n + 1\)/2，我们将证明如下的等价定理。

**定理：**当n ≥ 1时,

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image048.png)

**证明（归纳法）：**当n = 1时，定理是给出了正确的描述13 = 12\(22\)/4。归纳起来，如果这个定理在n = k 时成立

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image050.png)

当我们将等式两边同时加上 \(k + 1\)3 ，我们得到

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image052.png)  
 ![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image054.png)  
 ![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image056.png)  
 ![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image058.png)

定理得证

□

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p>&#x5173;&#x4E8E;&#x7ACB;&#x65B9;&#x6052;&#x7B49;&#x5F0F;&#xFF0C;&#x8FD8;&#x53EF;&#x4EE5;&#x7528;&#x51E0;&#x4F55;&#x7684;&#x65B9;&#x6CD5;&#x6765;&#x8BC1;&#x660E;&#x3002;</p>
        <p>
          <img src="file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image060.jpg"
          alt/>
        </p>
        <p>&#x8BA9;&#x6211;&#x4EEC;&#x7528;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x6765;&#x8BA1;&#x7B97;&#x8FD9;&#x4E2A;&#x56FE;&#x5F62;&#x7684;&#x9762;&#x79EF;&#xFF0C;&#x5E76;&#x6BD4;&#x8F83;&#x7ED3;&#x679C;&#x3002;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x56E0;&#x4E3A;&#x56FE;&#x5F62;&#x662F;&#x8FB9;&#x957F;&#x4E3A;
          1 + 2 + 3 + 4 + 5&#x7684;&#x6B63;&#x65B9;&#x5F62;&#xFF0C;&#x6240;&#x4EE5;&#x9762;&#x79EF;&#x662F;(
          1 + 2 + 3 + 4 + 5)&#xB2;&#x3002;</p>
        <p>&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x4ECE;&#x5DE6;&#x4E0A;&#x89D2;&#x5F00;&#x59CB;&#x6CBF;&#x5BF9;&#x89D2;&#x7EBF;&#x79FB;&#x52A8;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x770B;&#x5230;&#x4E00;&#x4E2A;1
          &#xD7; 1&#x7684;&#x6B63;&#x65B9;&#x5F62;&#xFF0C;&#x4E24;&#x4E2A;2 &#xD7;
          2&#x7684;&#x6B63;&#x65B9;&#x5F62;&#xFF08;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#x88AB;&#x7B49;&#x5206;&#x6210;&#x4E86;&#x4E24;&#x90E8;&#x5206;&#xFF09;&#x3001;3&#x4E2A;3
          &#xD7; 3&#x7684;&#x6B63;&#x65B9;&#x5F62;&#x3001;4&#x4E2A;4 &#xD7; 4&#x7684;&#x6B63;&#x65B9;&#x5F62;&#xFF08;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#x88AB;&#x7B49;&#x5206;&#x6210;&#x4E86;&#x4E24;&#x90E8;&#x5206;&#xFF09;&#x3001;5&#x4E2A;5
          &#xD7; 5&#x7684;&#x6B63;&#x65B9;&#x5F62;&#x3002;&#x6240;&#x4EE5;&#xFF0C;&#x603B;&#x9762;&#x79EF;&#x662F;</p>
        <p>(1 &#xD7; 1&#xB2;) + (2 &#xD7; 2&#xB2;) + (3 &#xD7; 3&#xB2;) + (4 &#xD7;
          4&#xB2;) + (5 &#xD7; 5&#xB2;) = 1&#xB3; + 2&#xB3; + 3&#xB3; <b>+</b> 4&#xB3; <b>+</b> 5&#xB3;</p>
        <p>&#x4F7F;&#x7528;&#x8FB9;&#x957F;1&#x3001;2 &#x3001; &#xB7; &#xB7; &#xB7;
          n&#x7684;&#x6B63;&#x65B9;&#x5F62;&#x53EF;&#x4EE5;&#x6784;&#x5EFA;&#x540C;&#x6837;&#x7684;&#x56FE;&#x5F62;&#xFF0C;&#x5E76;&#x8BC1;&#x660E;</p>
        <p>13 + 23 + 33 + &#xB7; &#xB7; &#xB7; + n&#xB3; = (1 + 2 + 3 + &#xB7; &#xB7;
          &#xB7; + n)&#xB2;</p>
        <p>&#x263A;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

归纳法不仅可以证明加法问题。那些可以可以被描述成较小的问题（大小为k）的“大”问题（大小为k + 1），经常也可用归纳法来证明。我最喜欢的一个归纳法的证明和本章开始时的棋盘填充问题有关。不过这次我们要证明的是可能性而不是不可能性。另外我们这次不用多米诺，而是使用托米诺（trominos作者自创词，tr表示3），这是一个由3个正方形组成的L型积木。

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg)

因为64不是3的倍数，我们不可能用托米诺铺满一个8 × 8的棋盘。但是，如果棋盘上有一个格子被遮盖，我们可以宣布托米诺积木可以将棋盘剩余的部分填满。事实上，该描述不仅仅对8 × 8的棋盘为真，对2 × 2、4 × 4、 16 × 16以及类似的棋盘都为真。

**定理：**对n ≥ 1，如果我们事先遮盖住2n × 2n 的棋盘上的一个格子，无论这个格子位于棋盘哪个位置，我们都可以用托米诺积木拼出来剩下的图形。

**证明（归纳法）：**n = 1时，定理成立，因为2 × 2的棋盘可以有一块托米诺和一个正方形组成。现在假设当n = k时，定理也成立。此时的棋盘大小是2k × 2k。我们的目标是证明2k+1 × 2k+1时，定理仍然成立。在棋盘上任选一个格子，接着将棋盘等分成四部分，每一部分的面积都是2k × 2k。我们得到如下的图形

![](file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image064.jpg)

现在包含选中格子的部分可以被托米诺铺满，这是我们在n = k时的假设。现在，我们在棋盘中心放置一块托米诺，这样其它三部分都有一个格子被遮盖住。按照n = k时的假设，它们剩余的部分也能够被托米诺铺满。这样我们证明了2k+1 × 2k+1也可以被托米诺铺满。

☺

本节最后一个恒等式有很多有用的应用。我们将用归纳法和其它的一些方法来证明它。一个刺激性的问题是：当你将2的前n\(n ≥ 0\)次幂加起来时，结果是什么？这里是最初的几个2的幂

1、2、4、8、16、32、64、128、256、512、1024. . .

当我们将它们加起来时，我们看到

                                                     1 = 1

                                               1 + 2 = 3

                                         1 + 2 + 4 = 7

                                   1 + 2 + 4 + 8 = 15

                           1 + 2 + 4 + 8 + 16 = 31

你看到其中的模型了吗？每个和都比下一个2的幂少1。通用的公式是：

**定理：**当 n ≥ 1,

1 + 2 + 4 + 8 + · · · + 2n−1 = 2n − 1

**证明（归纳法）：**如上所述，当n = 1时，定理是对的（2、3、4、5时同样是对的！）。假定n = k时，定理仍然成立

1 + 2 + 4 + 8 + · · · + 2k−1 = 2k − 1

当我们在等式两边同时加上下一个2的幂2k时，我们得到

1 + 2 + 4 + 8 + · · · + 2k−1 + 2k = \(2k − 1\) + 2k

                                                  = 2 × 2k − 1

                                                  = 2k + 1 − 1

□

在第4和第5章中，通过用两种不同的方式回答同一个计数问题，我们证明了很多关系。你可能会说下面关于组合的证明是最重要的。

**问：**一个有n个球员的曲棍球队（球衣号码1到n）有多少种方式可以选一个代表团参加至少有一名球员必须参加的会议？

**答案1：**每名队员有两种选择，参加或是不参加，所以答案看起来像是2n。但是我们必须排除没有球员参加会议的可能性。因此总的可能性有2n - 1种。

**答案2：**考虑参加会议的队员的最大号码。最大号码是1时，只有一种代表团。当2是最大号码时则有两种代表团（2号要么自己参加，要么和1号一起）。当3号是最大号码时，有4种代表团方案（3号必须参加，1号和2号各有两种选择）。以此类推，当n是最大号码时，则有2n-1种组团方案。因为n号必须参加，其它n - 1名队员各有2种选择。利用加法原理，总的可能性是1 + 2 + 4 + · · · + 2n−1种。

既然答案1和答案2都正确，那么它们必然相等。这样1 + 2 + 4 + · · · + 2n−1 = 2n − 1。

☺

也许更简单的证明只依赖于代数。这一方法让人想起我们用来将环小数转化为分数时用的方法。

**根据代数法证明**

令S = 1 + 2 + 4 + 8 + · · · + 2n−1

两边同时乘以2

2S = 2 + 4 + 8 + · · · + 2n−1 + 2n

将第一个恒等式从第二个中减去，只剩下S的第一项和2S的最后一项。

S = 2S − S = 2n − 1

□

我们刚刚证明的定理实际上是数的二进制表示法的关键，它是计算机存储和表示数的方法。二进制的思想是每个数都可以表示为2的不同幂的唯一和。例如

83 = 64 + 16 + 2 + 1

我们有二进制表示它，用1代替2的每一个幂，缺失的幂用0表示。在我们的例子中，83 = \(1 × 64\) + \(0 × 32\) + \(1 × 16\) + \(0 × 8\) + \(0 × 4\) + \(1 × 2\) + \(1 × 1\)。这样83用二进制表示就是

83 = \(1010011\)2

我们怎么知道每个正数都可以用这种方法表示？让我们假设1到99都可以用唯一一组2的幂之和的形式表示出来。我们如何知道100也可以有唯一的表示方法？让我们从64，小于100的最大的2的幂开始。我们必须包含64吗？答案是肯定的。因为1、2、4、8、16、32之和是63，比100小。一旦我们选择了64，我们需要利用2的幂凑成36。因为根据假设，我们有唯一的方式可凑成36。这就给了我们100的唯一表示。我们如何表示36呢？通过重复同样的逻辑，我们尽量选择最大的2的幂，并以此类推。这样36 = 32 + 4，所以100 = 64 + 32 + 4。100 的二进制表示就是 \(1100100\)2。我们可以推广这一论证（使用强归纳）来证明每一个正数都有唯一的二进制表示。

质数

在上一节中，我们确定每个正整数都可以被唯一表示成2的幂之和。在某种意义上，你可以说若只使用加法，2的幂是是正整数的构件块。在本节中，我们将看到质数在乘法中扮演了类似的角色：每一个正整数都可以唯一的表示为两个质数的积。2的幂很容易识别且有较少的数学惊喜。而质数则不同，它们更加复杂，有很多我们还不知道的东西。

质数是只能被1和它本身除尽的正整数。这里是一些质数2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53 . . .

1不是质数，因为它只有1这么一个因子（这不是1不是质数的主要原因，我们将在后面介绍）。注意，2是唯一一个偶质数。一些人认为这使得它是最奇怪（这里作者使用了双关，英文奇怪odd也有奇数的意思）的质数。

拥有两个以上因数的正整数被称为和数。因为它们可以被分解成更小的因数。前几个和数是

4、6、8、9、10、12、14、15、16、18、20、21、22、24、25、26、27、28、30 . . .

例如4有三个因数：1 、2和4。6有4个因数123和。注意1不是和数。

数学家称1为单元，因为它具有是任何一个整数的因子的属性。

每个和数都可以写成质数的积。让我们将120分解成质数的乘积。我们可以先写成120 = 6 × 20。现在6和20都是和数，我们可以将它们分解成质数乘积，6 = 2 × 3和20 = 2 × 2 × 5。这样

120 = 2 × 2 × 2 × 3 × 5 = 233151

有趣的是，无论我们怎么开始我们的分解，我们都将会得到相同的结果。这是**因数分解唯一性定理**的结果，也被称为**算术的基本定理**，它指出大于1的正整数都有唯一的质因数分解。

顺便说一下，如果1被视为质数，则该定理就不能够成立了。这是1不被视为质数的真正原因。例如，12分解质因子的结果是2 × 2 × 3，但是它也可以被分解成1 × 1 × 2 × 2 × 3，如果1是质数的话，则质因子分解就不具有唯一性了。

一旦你知道了一个数的因子，你就会更深入的了解这个数。当我们还是个孩子的时候，我最喜欢的数是9，随着我年龄的增大，我们喜欢的数越来越大，接着越来越复杂（例如π = 3.14159 . . . 、φ = 1.618 . . . 、e = 2.71828 . . . 、还有 i，它没有分数表示，我们将在第10章讨论它）。有段时间，在我认识无理数之前，我最喜欢的数是2520，因为它能够被1到10之间所有的数都能够除尽。

2520 = 23325171

一旦你知道了一个数的质数分解，你立即能够知道它有多少个因数。例如，2520可以分解成2a3b5c7d 的形式，其中a可以是0、1、2或3\(4种选择\)、b可以是0、1或2 \(3种选择\)、c可以是0或1 \(2种选择\)，d可以是0或1 \(2种选择\)。这样根据乘法原理，2520有4 × 3 × 2 × 2 = 48 个正因子。

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p>&#x7B97;&#x672F;&#x57FA;&#x672C;&#x5B9A;&#x7406;&#x7684;&#x8BC1;&#x660E;&#x5229;&#x7528;&#x4E86;&#x5173;&#x4E8E;&#x8D28;&#x6570;&#x7684;&#x4E0B;&#x5217;&#x4E8B;&#x5B9E;&#xFF08;&#x5728;&#x4EFB;&#x4F55;&#x6570;&#x8BBA;&#x6559;&#x79D1;&#x4E66;&#x7684;&#x7B2C;&#x4E00;&#x7AE0;&#x90FD;&#x6709;&#x8BC1;&#x660E;&#xFF09;&#x3002;&#x5982;&#x679C;p&#x662F;&#x8D28;&#x6570;&#x4E14;p&#x80FD;&#x591F;&#x9664;&#x5C3D;&#x4E24;&#x4E2A;&#x6570;&#x7684;&#x4E58;&#x79EF;&#xFF0C;&#x5219;p&#x80AF;&#x5B9A;&#x81F3;&#x5C11;&#x662F;&#x4E24;&#x4E2A;&#x6570;&#x5176;&#x4E00;&#x7684;&#x56E0;&#x6570;&#x3002;&#x4F8B;&#x5982;&#xFF0C;</p>
        <p>999,999 = 333 &#xD7; 3003</p>
        <p>&#x662F;11&#x7684;&#x500D;&#x6570;&#xFF0C;&#x6240;&#x4EE5;11&#x80AF;&#x5B9A;&#x53EF;&#x4EE5;&#x9664;&#x5C3D;333&#x6216;3003&#xFF08;&#x4E8B;&#x5B9E;&#x4E0A;3003
          = 11 &#xD7; 273&#xFF09;&#x3002;&#x8FD9;&#x4E2A;&#x5C5E;&#x6027;&#x5BF9;&#x548C;&#x6570;&#x5E76;&#x4E0D;&#x4E00;&#x5B9A;&#x6210;&#x7ACB;&#x3002;&#x4F8B;&#x5982;&#xFF0C;60
          = 6 &#xD7; 10&#x662F;4&#x7684;&#x500D;&#x6570;&#xFF0C;&#x4F46;&#x662F;4&#x4E0D;&#x80FD;&#x9664;&#x5C3D;6&#x6216;&#x8005;10&#x3002;</p>
        <p>&#x4E3A;&#x4E86;&#x8BC1;&#x660E;&#x552F;&#x4E00;&#x7684;&#x8D28;&#x56E0;&#x6570;&#x5206;&#x89E3;&#xFF0C;&#x5047;&#x8BBE;&#x6709;&#x4E9B;&#x6570;&#x7684;&#x8D28;&#x56E0;&#x6570;&#x5206;&#x89E3;&#x4E0D;&#x6B62;&#x4E00;&#x79CD;&#x3002;&#x5047;&#x8BBE;N&#x662F;&#x5177;&#x6709;&#x4E24;&#x79CD;&#x8D28;&#x56E0;&#x6570;&#x5206;&#x89E3;&#x7684;&#x6700;&#x5C0F;&#x7684;&#x6570;&#x3002;</p>
        <p>p1p2 &#xB7; &#xB7; &#xB7; pr = N = q1q2 &#xB7; &#xB7; &#xB7; qs</p>
        <p>&#x5176;&#x4E2D; pi&#x548C;qj &#x90FD;&#x662F;&#x8D28;&#x6570;&#x3002;&#x56E0;&#x4E3A;N&#x80AF;&#x5B9A;&#x662F;p1&#x7684;&#x500D;&#x6570;&#xFF0C;&#x5219;p1&#x5FC5;&#x987B;&#x662F;qj&#x7684;&#x9664;&#x6570;&#x3002;&#x4E3A;&#x4E86;&#x7B80;&#x5316;&#x7B26;&#x53F7;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x5047;&#x8BBE;p1&#x80FD;&#x9664;&#x5C3D;q1&#x3002;&#x56E0;&#x4E3A;q1&#x662F;&#x4E00;&#x4E2A;&#x8D28;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#x5FC5;&#x7136;&#x6709;q1
          = p1&#x3002;&#x6240;&#x4EE5;&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x5C06;&#x7B49;&#x5F0F;&#x4E24;&#x8FB9;&#x90FD;&#x9664;&#x4EE5;p1&#xFF0C;&#x6211;&#x4EEC;&#x5F97;&#x5230;</p>
        <p>
          <img src="file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image066.png"
          alt/>
        </p>
        <p>&#x4F46;&#x662F;&#x73B0;&#x5728;&#x6709;&#x4E24;&#x4E2A;&#x8D28;&#x56E0;&#x6570;&#x5206;&#x89E3;&#xFF0C;&#x8FD9;&#x548C;&#x6211;&#x4EEC;&#x4E4B;&#x524D;&#x5047;&#x8BBE;&#x7684;N&#x662F;&#x6700;&#x5C0F;&#x7684;&#x5177;&#x6709;&#x4E24;&#x4E2A;&#x8D28;&#x56E0;&#x6570;&#x5206;&#x89E3;&#x7684;&#x6570;&#x76F8;&#x77DB;&#x76FE;&#x3002;&#x6240;&#x4EE5;&#xFF0C;&#x6211;&#x4EEC;&#x7684;&#x5047;&#x8BBE;&#x4E0D;&#x6210;&#x7ACB;&#xFF0C;&#x5373;N&#x4E0D;&#x5B58;&#x5728;&#x4E24;&#x4E2A;&#x8D28;&#x56E0;&#x6570;&#x5206;&#x89E3;&#x3002;</p>
        <p>&#x25A1;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p>&#x987A;&#x4FBF;&#x8BF4;&#x4E00;&#x4E0B;&#xFF0C;&#x6709;&#x4E9B;&#x6570;&#x7CFB;&#x4E2D;&#x5E76;&#x4E0D;&#x662F;&#x6240;&#x6709;&#x6570;&#x90FD;&#x6709;&#x552F;&#x4E00;&#x7684;&#x56E0;&#x6570;&#x5206;&#x89E3;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x5728;&#x706B;&#x661F;&#x4E0A;&#xFF0C;&#x706B;&#x661F;&#x4EBA;&#x6709;&#x4E24;&#x4E2A;&#x8111;&#x888B;&#xFF0C;&#x5B83;&#x4EEC;&#x53EA;&#x7528;&#x5076;&#x6570;</p>
        <p>2&#x3001;4&#x3001;6&#x3001;8&#x3001;10&#x3001;12&#x3001;14&#x3001;16&#x3001;18&#x3001;20&#x3001;22&#x3001;24&#x3001;26&#x3001;28&#x3001;30&#x3001;.
          . .</p>
        <p>&#x5728;&#x706B;&#x661F;&#x7684;&#x6570;&#x7CFB;&#x4E2D;&#xFF0C;&#x50CF;6&#x548C;10&#x662F;&#x8D28;&#x6570;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x4E0D;&#x80FD;&#x88AB;&#x5206;&#x89E3;&#x6210;&#x66F4;&#x5C0F;&#x7684;&#x5076;&#x6570;&#x3002;&#x5728;&#x8FD9;&#x4E2A;&#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x8D28;&#x6570;&#x4E0E;&#x5408;&#x6570;&#x7B80;&#x5355;&#x7684;&#x4EA4;&#x66FF;&#x3002;&#x6BCF;&#x4E00;&#x4E2A;4&#x7684;&#x500D;&#x6570;&#x662F;&#x548C;&#x6570;&#xFF08;&#x56E0;&#x4E3A;4k
          = 2 &#xD7; 2k&#xFF09;&#x3002;&#x5176;&#x5B83;&#x7684;&#x5076;&#x6570;&#xFF08;&#x50CF;6&#x3001;10&#x3001;14&#x3001;18&#x4EE5;&#x6B64;&#x7C7B;&#x63A8;&#xFF09;&#x90FD;&#x662F;&#x8D28;&#x6570;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x4E0D;&#x80FD;&#x591F;&#x88AB;&#x5206;&#x89E3;&#x6210;&#x66F4;&#x5C0F;&#x7684;&#x5076;&#x6570;&#x3002;&#x73B0;&#x5728;&#x8003;&#x8651;180&#xFF1A;</p>
        <p>6 &#xD7; 30 = 180 = 10 &#xD7; 18</p>
        <p>&#x5728;&#x706B;&#x661F;&#x6570;&#x7CFB;&#x4E2D;&#xFF0C;180&#x53EF;&#x6309;&#x4E24;&#x79CD;&#x65B9;&#x5F0F;&#x88AB;&#x5206;&#x89E3;&#x6210;&#x8D28;&#x56E0;&#x6570;&#x76F8;&#x4E58;&#x7684;&#x5F62;&#x5F0F;&#x3002;&#x6240;&#x4EE5;&#x5206;&#x89E3;&#x8D28;&#x56E0;&#x6570;&#x5728;&#x8BE5;&#x661F;&#x7403;&#x6240;&#x7528;&#x7684;&#x6570;&#x7CFB;&#x4E2D;&#x5E76;&#x4E0D;&#x552F;&#x4E00;&#x3002;</p>
        <p>
          <img src="file:///C:/Users/samuel/AppData/Local/Temp/msohtmlclip1/01/clip_image068.jpg"
          alt/>
        </p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

在1到100之间，有25个质数。在接下来的100个数中，有21个质数，再后面的100个数中有16个质数。当我们看越来越大的数时，质数变得越来越少（但不是以一种可预测的方式，比如在300到400之间有16个质数，在400到500之间则有17个质数）。在100万到1000,100之间只有6个质数。事实上，质数变得越来越少很好理解，因为一个大的数有很多小于它的数，其中很可能包含它的因数。

我们可以证明存在连续的100个合数。只要你愿意，甚至还会有连续1000个，或100万个。让我试着用99个连续的合数\(尽管这不是第一次发生\)来让你相信这个事实。考虑一下99个连续的数。

100! + 2、100! + 3、100! + 4、. . . 、100! + 100

因为 100! = 100 × 99 × 98 × · · · × 3 × 2 × 1，它肯定能被2到100间任一个数除尽。现在考虑类似100! + 53的数。因为53可以除尽100!，则它也能够除尽100! + 53。相同的论证证明对2 ≤ k ≤ 100、100! + k肯定是k的倍数，所以它肯定是一个合数。

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p>&#x6CE8;&#x610F;&#x6211;&#x4EEC;&#x7684;&#x8BC1;&#x660E;&#x672A;&#x6D89;&#x53CA;&#x6700;&#x5F00;&#x59CB;&#x7684;
          100! + 1&#xFF0C;&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x786E;&#x5B9A;&#x5B83;&#x662F;&#x5408;&#x6570;&#x3002;&#x6709;&#x4E00;&#x4E2A;&#x7F8E;&#x4E3D;&#x7684;&#x5B9A;&#x7406;&#x53EB;&#x5A01;&#x5C14;&#x900A;&#x5B9A;&#x7406;&#xFF1A;&#x5F53;&#x4E14;&#x4EC5;&#x5F53;n&#x662F;&#x8D28;&#x6570;&#x65F6;&#xFF0C;(n
          &#x2212; 1)! + 1&#x662F;n&#x7684;&#x500D;&#x6570;&#x65F6;&#x3002;&#x8BD5;&#x7740;&#x7528;&#x51E0;&#x4E2A;&#x8F83;&#x5C0F;&#x7684;&#x6570;&#x6765;&#x770B;&#x770B;&#x5B83;&#x662F;&#x5426;&#x8D77;&#x4F5C;&#x7528;&#xFF1A;1!
          + 1 = 2&#x662F;2&#x7684;&#x500D;&#x6570;&#xFF1B;2! + 1 = 3&#x662F;3&#x7684;&#x500D;&#x6570;&#xFF1B;3!
          + 1 = 7&#x4E0D;&#x662F;4&#x7684;&#x500D;&#x6570;&#xFF1B;4! + 1 = 25&#x662F;5&#x7684;&#x500D;&#x6570;&#xFF1B;5!
          + 1 = 121&#x4E0D;&#x662F;6&#x7684;&#x500D;&#x6570;&#xFF1B;6! + 1 = 721&#x662F;7&#x7684;&#x500D;&#x6570;&#xFF1B;&#x7B49;&#x7B49;&#x3002;&#x56E0;&#x4E3A;101&#x662F;&#x8D28;&#x6570;&#xFF0C;&#x6839;&#x636E;&#x5A01;&#x5C14;&#x900A;&#x5B9A;&#x7406;100!
          + 1&#x662F;101&#x7684;&#x500D;&#x6570;&#xFF0C;&#x56E0;&#x6B64;&#x5B83;&#x662F;&#x5408;&#x6570;&#x3002;&#x8FD9;&#x6837;&#x4ECE;100
          !&#x5230;100! + 100&#x7684;101&#x4E2A;&#x8FDE;&#x7EED;&#x6570;&#x90FD;&#x662F;&#x5408;&#x6570;&#x3002;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

在非常大的数中，质数变得越来越稀少。人们自然会想，在某个时刻，我们的质数是否已经用光了。就像两千多年前欧几里得告诉我们的那样，事实并非如此。但不要只是相信他的话；享受你自己的证明吧。

**定理：**质数有无穷多个。

**证明：**假设只有有限个质数。因此肯定有一个最大的质数，我们将它用p表示，现在考虑p! + 1。因为p!可以被2和p之间的所有数整除，这些数都不能整除p! + 1。因此，p! + 1必须有大于p的质数因子，这与p是最大质数的假设相矛盾。

**□**

虽然我们永远找不到一个最大的质数，但这并不能阻止数学家和计算机科学家寻找更大的质数。在这篇文章中，已知的最大质数有17,425,170位。把这个数写下来，大概需要100本与本书大小差不多的书。但是我们可以用一行来描述这个数字。

257,885,161 − 1

它之所以有这么简单的形式是因为有一种特别有效的方法来确定2n - 1或2n + 1是否为素数。

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p>&#x4F1F;&#x5927;&#x7684;&#x6570;&#x5B66;&#x5BB6;&#x8D39;&#x9A6C;&#xFF08;pierre
          de fermat&#xFF09;&#x8BC1;&#x660E;&#x4E86;&#x5982;&#x679C;p&#x662F;&#x4E00;&#x4E2A;&#x5947;&#x6570;&#x8D28;&#x6570;&#xFF0C;&#x90A3;&#x4E48;2p
          - 1 - 1&#x80AF;&#x5B9A;&#x662F;p&#x7684;&#x500D;&#x6570;&#x3002;&#x5BF9;&#x4E8E;&#x8D28;&#x6570;3&#x3001;5&#x3001;7&#x3001;11&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230;22
          - 1 = 3&#x662F;3&#x7684;&#x500D;&#x6570;&#xFF1B;24 - 1 = 15&#x662F;5&#x7684;&#x500D;&#x6570;&#xFF1B;26
          - 1 = 63&#xFF0C;&#x662F;7&#x7684;&#x500D;&#x6570;&#xFF1B;210 - 1 = 1023&#x662F;11&#x7684;&#x500D;&#x6570;&#x3002;&#x81F3;&#x4E8E;&#x5408;&#x6570;&#xFF0C;&#x5F88;&#x660E;&#x663E;&#xFF0C;&#x5982;&#x679C;n&#x662F;&#x5076;&#x6570;&#xFF0C;&#x90A3;&#x4E48;2n
          - 1 - 1&#x80AF;&#x5B9A;&#x662F;&#x5947;&#x6570;&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x4E0D;&#x53EF;&#x80FD;&#x662F;n&#x7684;&#x500D;&#x6570;&#x3002;&#x68C0;&#x67E5;&#x524D;&#x51E0;&#x4E2A;&#x5947;&#x5408;&#x6570;9&#x3001;15&#x548C;21&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230;28
          &#x2212; 1 = 255 &#x4E0D;&#x662F;&#x4E00;&#x4E2A;9&#x7684;&#x500D;&#x6570;&#xFF1B;214
          &#x2212; 1 = 16,383&#x4E5F;&#x4E0D;&#x662F;15&#x7684;&#x500D;&#x6570;&#xFF0C;220
          &#x2212; 1 = 1,048,575&#x4E0D;&#x662F;21&#x7684;&#x500D;&#x6570;&#xFF08;&#x751A;&#x81F3;&#x4E0D;&#x662F;3&#x7684;&#x500D;&#x6570;&#xFF09;&#x3002;&#x6839;&#x636E;&#x8D39;&#x9A6C;&#x7684;&#x5B9A;&#x7406;&#xFF08;&#x8BE5;&#x5B9A;&#x7406;&#x88AB;&#x79F0;&#x4E3A;&#x8D39;&#x9A6C;&#x5C0F;&#x5B9A;&#x7406;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x5F88;&#x5927;&#x7684;&#x6570;N&#xFF0C;2N&#x2212;1&#x2212;1&#x4E0D;&#x662F;N&#x7684;&#x500D;&#x6570;&#xFF0C;&#x5219;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x767E;&#x5206;&#x4E4B;&#x767E;&#x786E;&#x5B9A;N&#x4E0D;&#x662F;&#x4E00;&#x4E2A;&#x8D28;&#x6570;&#x3002;&#x751A;&#x81F3;&#x90FD;&#x4E0D;&#x9700;&#x8981;&#x77E5;&#x9053;N&#x7684;&#x56E0;&#x6570;&#xFF01;&#x7136;&#x800C;&#x8D39;&#x9A6C;&#x5C0F;&#x5B9A;&#x7406;&#x7684;&#x9006;&#x5B9A;&#x7406;&#x5E76;&#x4E0D;&#x6210;&#x7ACB;&#x3002;&#x5B58;&#x5728;&#x4E00;&#x4E9B;&#x5408;&#x6570;&#xFF08;&#x79F0;&#x4E3A;&#x4F2A;&#x8D28;&#x6570;&#xFF09;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x9006;&#x5B9A;&#x7406;&#x6210;&#x7ACB;&#x3002;&#x6700;&#x5C0F;&#x7684;&#x4F8B;&#x5B50;&#x662F;
          341 = 11 &#xD7; 31&#xFF0C;2340 &#x2212; 1 &#x662F;341&#x7684;&#x500D;&#x6570;&#x3002;&#x867D;&#x7136;&#x6709;&#x8BC1;&#x636E;&#x8868;&#x660E;&#xFF0C;&#x4F2A;&#x8D28;&#x6570;&#x662F;&#x76F8;&#x5BF9;&#x5C11;&#x89C1;&#x7684;&#xFF0C;&#x4F46;&#x6709;&#x65E0;&#x6570;&#x4E2A;&#xFF0C;&#x6709;&#x4E00;&#x4E9B;&#x6D4B;&#x8BD5;&#x53EF;&#x4EE5;&#x5254;&#x9664;&#x5B83;&#x4EEC;&#x3002;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

质数有很多应用，尤其是在计算机科学领域。质数几乎是每一种加密算法的核心，包括公钥密码术，它允许在互联网上进行安全的金融交易。这些算法中的许多都是基于这样一个事实，即虽然可以快速确定一个数是否是质数，但是没有快速对大数进行质因数分解的方法。举个例子，如果我把两个随机的1000位的质数相乘，然后给你2000位的乘积。那么任何一个人或计算机\(除非一个量子计算机\)都是不可能判断出最初的两个质数。基于我们无法将大数分解的代码\(如rsa方法\)被认为是相当安全的。

人们着迷于质数了数千年。如果一个数恰恰等于它所有的真因子之和\(它本身除外\)，古希腊人认为这是一个完美的数。例如，6是完美的，因为它的真因子1、2、3之和恰恰是6。下一个完美数是28，真因子1、2、4、7、14之和是28。接下来的两个完美的数是496和8128。有什么模式吗？让我们看看它们的质因数分解。

6         = 2 × 3

28       = 4 × 7

496     = 16 × 31

8128   = 64 × 127

你看到模式了吗？第一个数是2的幂，第二个数是2的2倍减1，它是一个质数。这就是为什么你在列表上看不到8 × 15或32 × 63的原因，因为15和63不是质数。我们可以在下面的定理中总结这个模式。

**定理：**如果2n − 1 是质数，那么 2n−1 × \(2n − 1\) 是完美数。

<table>
  <thead>
    <tr>
      <th style="text-align:left">
        <p><b>&#x65C1;&#x767D;</b>
        </p>
        <p><b>&#x8BC1;&#x660E;&#xFF1A;</b>&#x4EE4;p = 2n &#x2212;1 &#x662F;&#x4E00;&#x4E2A;&#x8D28;&#x6570;&#x3002;&#x6211;&#x4EEC;&#x7684;&#x76EE;&#x7684;&#x662F;&#x8BC1;&#x660E;2n&#x2212;1p
          &#x662F;&#x5B8C;&#x7F8E;&#x6570;&#x3002;2n&#x2212;1p &#x7684;&#x771F;&#x56E0;&#x5B50;&#x6709;&#x54EA;&#x4E9B;&#xFF1F;&#x6CA1;&#x6709;&#x7528;&#x5230;p&#x7684;&#x56E0;&#x5B50;&#x6BD4;&#x8F83;&#x7B80;&#x5355;1&#x3001;2&#x3001;4&#x3001;8.
          . . 2n&#x2212;1&#xFF0C;&#x5B83;&#x4EEC;&#x7684;&#x548C;&#x662F;2n &#x2212;1
          = p&#x3002;&#x5176;&#x5B83;&#x7684;&#x771F;&#x56E0;&#x5B50;&#x90FD;&#x662F;p&#x7684;&#x500D;&#x6570;&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x4EEC;&#x7684;&#x548C;&#x662F;p(1
          + 2 + 4 + 8 + &#xB7; &#xB7; &#xB7; + 2n&#x2212;2) = p(2n&#x2212;1 &#x2212;
          1)&#x3002;&#x8FD9;&#x6837;&#x771F;&#x56E0;&#x5B50;&#x7684;&#x603B;&#x548C;&#x662F;</p>
        <p>p + p(2n&#x2212;1 &#x2212; 1) = p(1 + (2n&#x2212;1 &#x2212; 1)) = 2n&#x2212;1p</p>
        <p>&#x25A1;</p>
      </th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

伟大的数学家莱昂哈德·欧拉\(1707 -1783\)证明了每一个完美数都是这种形式。在本书写作的时候，已经有48个完美数被发现，它们都是偶数。有什么奇完美数吗？目前，没有人知道该问题的答案。已经证明，如果一个奇数完美数存在，那么它将必须包含超过300个数字，但是还没有人证明它们是不可能存在的。

关于质数，有许多容易表述的问题仍未解决。我们已经说过，是否有无穷多个斐波那契质数还未确定（已经证明：斐波那契数列中，只有两个平方数（1、144）和两个立方数（1、8））。另一个未解决的问题是哥德巴赫猜想，它推测每一个大于2的偶数是两个质数的和。在这里，也没有人能够证明这个猜想，但事实证明，如果一个反例存在，那么它至少必须有19位（最近在一个类似的问题上取得了突破。2013年，harald helfgott证明，每一个大于7的奇数都是最多3个奇数的和）。最后，我们定义了差值为2的两个质数为孪生质数。孪生质数的最初的例子分别是3和5，5和7，11和13，17和19，29和31等等。你能看到为什么3、5和7是唯一的三胞胎质数吗？尽管已经证明\(作为古斯塔夫狄利克雷定理的一个特例\)有无穷多个素数以1\(或3，或7，或9\)结尾，是否存在无穷多的孪生素数仍未解决。

让我们以一个有点可疑的证明结束这一章，但我希望你同意这个说法。

**声明：**所有的整数都很有趣！

**证明？：**你会同意最初的几个正数都很有趣。例如，1是第一个数，2是第一个偶数，3是第一个奇数质数，4是唯一一个表示f-o-u-r的数，以此类推。现在假设，相反，不是所有的数都是有趣的。那么就必须有个开始，这个数我们称之为N，它一点都没有趣。但第一个无趣的数将使N有趣！因此，没有无趣的数存在。

☺

